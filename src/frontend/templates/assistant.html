{{ define "assistant" }} {{ template "header" . }}
<div {{ with $.platform_css }} class="{{.}}" {{ end }}>
  <span class="platform-flag"> {{$.platform_name}} </span>
</div>

<main role="main">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div id="chat-modal" class="chat-modal">
          <div id="bot-messages" class="bot-messages">
            <p class="bot-message">
              <span class="bot-message-text"
                >Hi! I'm your Online Boutique shopping assistant powered by
                Gemini 2.0 Flash. I can help you find products, answer questions
                about our catalog, and make personalized recommendations.</span
              >
            </p>
            <p class="bot-message">
              <span class="bot-message-text"
                >What are you looking for today? You can ask me about specific
                products, categories, or just tell me what you need!</span
              >
            </p>
          </div>
          <div class="bot-input">
            <input
              id="bot-input-text"
              type="text"
              class="bot-input-text"
              placeholder="Ask me about products, categories, or what you're looking for..."
            />
            <button id="bot-input-button" class="bot-input-button">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
  // Store conversation history for context
  var conversationHistory = [];
  var sessionId = null;

  // Load session from localStorage
  function loadSession() {
    try {
      const savedSession = localStorage.getItem('chatSessionId');
      const savedHistory = localStorage.getItem('chatHistory');

      if (savedSession) {
        sessionId = savedSession;
      } else {
        sessionId =
          'session_' +
          Date.now() +
          '_' +
          Math.random().toString(36).substr(2, 9);
        localStorage.setItem('chatSessionId', sessionId);
      }

      if (savedHistory) {
        conversationHistory = JSON.parse(savedHistory);

        // Restore chat messages from history if we have any
        if (conversationHistory.length > 0) {
          // Clear default greeting messages
          botMessages.innerHTML = '';

          // Rebuild conversation UI from history
          conversationHistory.forEach((msg) => {
            if (msg.startsWith('User: ')) {
              const userMsg = msg.substring(6);
              const usermessage = document.createElement('p');
              const userMessageSpan = document.createElement('span');
              userMessageSpan.innerText = userMsg;
              userMessageSpan.classList.add('user-message-text');
              usermessage.classList.add('user-message');
              usermessage.appendChild(userMessageSpan);
              botMessages.appendChild(usermessage);
            } else if (msg.startsWith('Assistant: ')) {
              const botMsg = msg.substring(11);
              const botMessage = document.createElement('p');
              const botMessageSpan = document.createElement('span');
              botMessageSpan.innerHTML = parseMarkdown(
                botMsg.replace(/\n+[-*\d][\S\s]*/g, '')
              );
              botMessageSpan.classList.add('bot-message-text');
              botMessage.classList.add('bot-message');
              botMessage.appendChild(botMessageSpan);
              botMessages.appendChild(botMessage);
            }
          });

          botMessages.scrollTo(0, botMessages.scrollHeight);
        }
      }
    } catch (e) {
      console.error('Failed to load session:', e);
    }
  }

  // Save session to localStorage
  function saveSession() {
    try {
      localStorage.setItem('chatHistory', JSON.stringify(conversationHistory));
    } catch (e) {
      console.error('Failed to save session:', e);
    }
  }

  // Parse markdown to HTML
  function parseMarkdown(text) {
    // Convert product IDs to clickable links first
    // Pattern: [PRODUCT_ID] becomes a clickable link
    let html = text.replace(/\[([A-Z0-9]+)\]/g, function (match, productId) {
      return `<a href="{{ $.baseUrl }}/product/${productId}" style="color: #4285f4; text-decoration: underline;">[${productId}]</a>`;
    });

    // Basic markdown parsing
    html = html
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .replace(/^\* (.+)$/gm, '<li>$1</li>')
      .replace(/^- (.+)$/gm, '<li>$1</li>')
      .replace(/^\d+\. (.+)$/gm, '<li>$1</li>')
      .replace(/\n/g, '<br>');

    html = html.replace(/(<li>.*?<\/li>(<br>)?)+/g, function (match) {
      return '<ul>' + match.replace(/<br>/g, '') + '</ul>';
    });

    return html;
  }

  function extractIdsFromString(message) {
    const idPattern = /\[([a-zA-Z0-9-]+)\]/g;
    const matches = message.matchAll(idPattern);
    const ids = [];
    for (const match of matches) {
      ids.push(match[1]);
    }

    return ids;
  }

  const chatModal = document.getElementById('chat-modal');
  const botMessages = document.getElementById('bot-messages');
  const botbutton = document.getElementById('bot-input-button');
  const botinput = document.getElementById('bot-input-text');

  async function main() {
    // Load session on page load
    loadSession();

    botbutton.addEventListener('click', handleButtonClick);

    botinput.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        botbutton.click();
      }
    });
  }

  async function handleButtonClick() {
    if (!botinput.value || !botinput.value.trim()) {
      return;
    }

    // Construct and render user message
    console.log('bot button clicked');
    const message = botinput.value;
    console.log('message: ' + message);

    // Add to conversation history
    conversationHistory.push('User: ' + message);

    const usermessage = document.createElement('p');
    const userMessageSpan = document.createElement('span');
    userMessageSpan.innerText = message;
    userMessageSpan.classList.add('user-message-text');
    usermessage.classList.add('user-message');
    usermessage.appendChild(userMessageSpan);
    botMessages.appendChild(usermessage);
    botMessages.scrollTo(0, botMessages.scrollHeight);
    botinput.value = '';

    // Disable send button and input field
    botbutton.disabled = true;
    botinput.disabled = true;
    console.log('bot is typing');

    // Always use streaming
    let responseJson = null;
    let botMessage = null;
    let botMessageSpan = null;
    let extractedIds = [];

    // Create bot message for streaming
    botMessage = document.createElement('p');
    botMessageSpan = document.createElement('span');
    botMessageSpan.innerHTML = '';
    botMessageSpan.classList.add('bot-message-text');
    botMessage.classList.add('bot-message');
    botMessage.appendChild(botMessageSpan);
    botMessages.appendChild(botMessage);
    botMessages.scrollTo(0, botMessages.scrollHeight);

    let fullResponse = '';
    let metadata = null;

    try {
      const response = await fetch('{{ $.baseUrl }}/chat/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: message,
          history: conversationHistory.slice(-10),
          session_id: sessionId,
        }),
      });

      if (!response.ok) {
        console.error('Streaming endpoint returned error:', response.status);
        botMessageSpan.innerHTML =
          'Sorry, I encountered an error. Please try again.';
        return;
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data) {
              try {
                const parsed = JSON.parse(data);
                if (parsed.text) {
                  fullResponse += parsed.text;
                  botMessageSpan.innerHTML = parseMarkdown(
                    fullResponse.replace(/\n+[-*\d][\S\s]*/g, '')
                  );
                  botMessages.scrollTo(0, botMessages.scrollHeight);
                } else if (parsed.metadata) {
                  metadata = parsed.metadata;
                  if (metadata.session_id) {
                    sessionId = metadata.session_id;
                    localStorage.setItem('chatSessionId', sessionId);
                  }
                  if (metadata.recommended_products) {
                    extractedIds = metadata.recommended_products;
                  }
                } else if (parsed.done) {
                  break;
                }
              } catch (e) {
                console.error('Error parsing SSE:', e);
              }
            }
          }
        }
      }

      conversationHistory.push('Assistant: ' + fullResponse);
      saveSession();
      responseJson = { message: fullResponse };
    } catch (error) {
      console.error('Streaming failed:', error);
      botMessageSpan.innerHTML =
        'Sorry, I encountered an error. Please try again.';
    }

    // If there are any product IDs...
    if (extractedIds.length > 0) {
      // Construct root products div
      const botProductsDiv = document.createElement('div');
      botProductsDiv.classList.add('bot-products');

      // For each product...
      for (const id of extractedIds) {
        // Retrieve product metadata from the Product Catalog
        const productResponse = await fetch(
          '{{ $.baseUrl }}/product-meta/' + id,
          {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
            },
          }
        );
        const product = await productResponse.json();

        // Construct main product div
        const botProductDiv = document.createElement('a');
        botProductDiv.classList.add('bot-product');
        botProductDiv.href = '{{ $.baseUrl }}/product/' + id;

        // Construct product image
        const botProductImg = document.createElement('img');
        botProductImg.src = product['picture'];
        botProductImg.classList.add('bot-product-img');
        botProductImg.onerror = function () {
          this.style.display = 'none';
        };
        botProductDiv.appendChild(botProductImg);

        // Construct product description div
        const botProductDescription = document.createElement('div');
        botProductDescription.classList.add('bot-product-description');
        let productDescription = product['description'];
        if (productDescription.length > 350) {
          // Shorten descriptions that are too long
          productDescription = productDescription.substring(0, 330) + '...';
        }
        botProductDescription.innerHTML =
          '<b>' + product['name'] + '</b><br>' + productDescription;
        botProductDiv.appendChild(botProductDescription);

        // Append main product div into the root products div
        botProductsDiv.appendChild(botProductDiv);
      }
      // Render products
      botMessages.appendChild(botProductsDiv);
    }

    botMessages.scrollTo(0, botMessages.scrollHeight);

    // Re-enable button and input field
    botbutton.disabled = false;
    botinput.disabled = false;
    botinput.focus();
  }

  main();
</script>

{{ end }}
